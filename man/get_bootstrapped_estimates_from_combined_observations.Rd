% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipe.R
\name{get_bootstrapped_estimates_from_combined_observations}
\alias{get_bootstrapped_estimates_from_combined_observations}
\title{Estimate Re from incidence and estimate uncertainty by bootstrapping}
\usage{
get_bootstrapped_estimates_from_combined_observations(
  partially_delayed_incidence,
  fully_delayed_incidence,
  smoothing_method = "LOESS",
  deconvolution_method = "Richardson-Lucy delay distribution",
  estimation_method = "EpiEstim sliding window",
  bootstrapping_method = "non-parametric block boostrap",
  uncertainty_summary_method = "original estimate - CI from bootstrap estimates",
  combine_bootstrap_and_estimation_uncertainties = FALSE,
  N_bootstrap_replicates = 100,
  delay_until_partial,
  delay_until_final_report,
  partial_observation_requires_full_observation = TRUE,
  correct_before_smoothing = TRUE,
  ref_date = NULL,
  time_step = "day",
  output_Re_only = TRUE,
  ...
)
}
\arguments{
\item{partially_delayed_incidence}{An object containing incidence data through time.
It can be:
\itemize{
\item A list with two elements:
\enumerate{
\item A numeric vector named \code{values}: the incidence recorded on consecutive time steps.
\item An integer named \code{index_offset}: the offset, counted in number of time steps,
by which the first value in \code{values} is shifted compared to a reference time step
This parameter allows one to keep track of the date of the first value in \code{values}
without needing to carry a \code{date} column around.
A positive offset means \code{values} are delayed in the future compared to the reference values.
A negative offset means the opposite.
}
\item A numeric vector. The vector corresponds to the \code{values} element
descrived above, and \code{index_offset} is implicitely zero.
This means that the first value in \code{incidence_data}
is associated with the reference time step (no shift towards the future or past).
}}

\item{fully_delayed_incidence}{An object containing incidence data through time.
It can be:
\itemize{
\item A list with two elements:
\enumerate{
\item A numeric vector named \code{values}: the incidence recorded on consecutive time steps.
\item An integer named \code{index_offset}: the offset, counted in number of time steps,
by which the first value in \code{values} is shifted compared to a reference time step
This parameter allows one to keep track of the date of the first value in \code{values}
without needing to carry a \code{date} column around.
A positive offset means \code{values} are delayed in the future compared to the reference values.
A negative offset means the opposite.
}
\item A numeric vector. The vector corresponds to the \code{values} element
descrived above, and \code{index_offset} is implicitely zero.
This means that the first value in \code{incidence_data}
is associated with the reference time step (no shift towards the future or past).
}}

\item{smoothing_method}{string. Method used to smooth the original incidence data.
Available options are:
\itemize{
\item{'LOESS', implemented in \code{\link{.smooth_LOESS}}}
}}

\item{deconvolution_method}{string. Method used to infer timings of infection
events from the original incidence data (aka deconvolution step).
Available options are:
\itemize{
\item{'Richardson-Lucy delay distribution',
implemented in \code{\link{.deconvolve_incidence_Richardson_Lucy}}}
}}

\item{estimation_method}{string. Method used to estimate reproductive number
values through time from the reconstructed infection timings.
Available options are:
\itemize{
\item{'EpiEstim sliding window',
implemented in \code{\link{.estimate_Re_EpiEstim_sliding_window}}}
\item{'EpiEstim piecewise constant',
implemented in \code{\link{.estimate_Re_EpiEstim_piecewise_constant}}}
}}

\item{bootstrapping_method}{string. Method to perform bootstrapping
of the original incidence data.
Available options are:
\itemize{
\item{'non-parametric block boostrap',
implemented in \code{\link{.block_bootstrap}}}
}}

\item{uncertainty_summary_method}{string. One of the following options:
\itemize{
\item{'NONE' if no summary of bootstrap estimates is required}
\item{'original estimate - CI from bootstrap estimates'.
The confidence interval is built using bootstrapped estimates
and centered around the original estimates.}
\item{'bagged mean - CI from bootstrap estimates'.
The confidence interval is built using bootstrapped estimates
and centered around the mean of bootstrapped estimates and original estimates.}
}}

\item{combine_bootstrap_and_estimation_uncertainties}{boolean.
If TRUE, the uncertainty interval reported is the union of
the highest posterior density interval from the Re estimation
with the confidence interval from the boostrapping of time series
of observations.}

\item{N_bootstrap_replicates}{integer. Number of bootstrap samples.}

\item{delay_until_partial}{Single delay or list of delays.
Each delay can be one of:
\itemize{
\item{a list representing a distribution object}
\item{a discretized delay distribution vector}
\item{a discretized delay distribution matrix}
\item{a dataframe containing empirical delay data}
}}

\item{delay_until_final_report}{Single delay or list of delays.
Each delay can be one of:
\itemize{
\item{a list representing a distribution object}
\item{a discretized delay distribution vector}
\item{a discretized delay distribution matrix}
\item{a dataframe containing empirical delay data}
}}

\item{partial_observation_requires_full_observation}{boolean
Set to \code{TRUE} if \code{partially_delayed_incidence} represent
delayed observations of infection events that
themselves rely on further-delayed observations.
See Details for more details.}

\item{correct_before_smoothing}{Boolean.
Default is TRUE, parameter exists only for comparison purposes.}

\item{ref_date}{Date. Optional. Date of the first data entry in \code{incidence_data}}

\item{time_step}{string. Time between two consecutive incidence datapoints.
"day", "2 days", "week", "year"... (see \code{\link[base]{seq.Date}} for details)}

\item{output_Re_only}{boolean. Should the output only contain Re estimates?
(as opposed to containing results for each intermediate step)}

\item{...}{
  Arguments passed on to \code{\link[=.smooth_LOESS]{.smooth_LOESS}}, \code{\link[=.deconvolve_incidence_Richardson_Lucy]{.deconvolve_incidence_Richardson_Lucy}}, \code{\link[=.estimate_Re_EpiEstim_sliding_window]{.estimate_Re_EpiEstim_sliding_window}}, \code{\link[=.estimate_Re_EpiEstim_piecewise_constant]{.estimate_Re_EpiEstim_piecewise_constant}}, \code{\link[=merge_outputs]{merge_outputs}}, \code{\link[=correct_for_partially_observed_data]{correct_for_partially_observed_data}}
  \describe{
    \item{\code{data_points_incl}}{integer. Size of the window used in the LOESS algorithm.
The \code{span} parameter passed to \code{\link[stats]{loess}} is computed as
the ratio of \code{data_points_incl} and the number of time steps in the input data.}
    \item{\code{degree}}{integer. LOESS degree. Must be 0, 1 or 2.}
    \item{\code{initial_Re_estimate_window}}{integer. In order to help with the smoothing, the function extends
the data back in time, padding with values obtained by assuming a constant Re. This parameter represents
the number of timesteps in the beginning of \code{incidence_input} to take into account when computing
the average initial Re.}
    \item{\code{left_pad_with_zeroes}}{boolean. Default is FALSE. Used for testing only.}
    \item{\code{delay_distribution}}{numeric square matrix or vector.}
    \item{\code{threshold_chi_squared}}{numeric scalar. Threshold for chi-squared values under which the R-L algorithm stops.}
    \item{\code{constant_right_padding}}{Boolean. Default is FALSE. Only used for testing.}
    \item{\code{max_iterations}}{integer. Maximum threshold for the number of iterations in the R-L algorithm.}
    \item{\code{verbose}}{Boolean. Print verbose output?}
    \item{\code{estimation_window}}{Use with \code{estimation_method = "EpiEstim sliding window"}
Positive integer value.
Number of data points over which to assume Re to be constant.}
    \item{\code{import_incidence_input}}{NULL or module input object.
List with two elements:
\enumerate{
\item A numeric vector named \code{values}: the incidence recorded on consecutive time steps.
\item An integer named \code{index_offset}: the offset, counted in number of time steps,
by which the first value in \code{values} is shifted compared to a reference time step
This parameter allows one to keep track of the date of the first value in \code{values}
without needing to carry a \code{date} column around.
A positive offset means \code{values} are delayed in the future compared to the reference values.
A negative offset means the opposite.
}
If not NULL, this data represents recorded imported cases.
And then \code{incidence_input} represents only local cases.}
    \item{\code{minimum_cumul_incidence}}{Numeric value.
Minimum number of cumulated infections before starting the Re estimation.
Default is \code{12} as recommended in Cori et al., 2013.}
    \item{\code{mean_serial_interval}}{Numeric positive value. \code{mean_si} for \code{\link[EpiEstim]{estimate_R}}}
    \item{\code{std_serial_interval}}{Numeric positive value. \code{std_si} for \code{\link[EpiEstim]{estimate_R}}}
    \item{\code{mean_Re_prior}}{Numeric positive value. \code{mean prior} for \code{\link[EpiEstim]{estimate_R}}}
    \item{\code{output_HPD}}{Boolean. If TRUE, return the highest posterior density interval with the output.}
    \item{\code{interval_ends}}{Use with \code{estimation_method = "EpiEstim piecewise constant"}
Integer vector. Optional argument.
If provided, \code{interval_ends} overrides the \code{interval_length} argument.
Each element of \code{interval_ends} specifies the right boundary
of an interval over which Re is assumed to be constant for the calculation.
Values in \code{interval_ends} must be integer values corresponding
with the same numbering of time steps as given by \code{incidence_input}.
In other words, \code{interval_ends} and \code{incidence_input},
use the same time step as the zero-th time step.}
    \item{\code{interval_length}}{Use with \code{estimation_method = "EpiEstim piecewise constant"}
Positive integer value.
Re is assumed constant over steps of size \code{interval_length}.}
    \item{\code{cutoff_observation_probability}}{value between 0 and 1.
Only datapoints for timesteps that have a probability of observing a event
higher than \code{cutoff_observation_probability} are kept.
The few datapoints with a lower probability to be observed are trimmed off
the tail of the timeseries.}
  }}
}
\value{
Effective reproductive estimates through time with confidence interval boundaries.
If \code{output_Re_only} is \code{FALSE}, then transformations made
on the input observations during calculations are output as well.
}
\description{
An estimation of the effective reproductive number through time is made
on the original incidence data.
Then, the same estimation is performed on a number of bootstrap samples built from the original incidence data.
The estimate on the original data is output along with confidence interval boundaries
built from the distribution of bootstrapped estimates.
}
\details{
This function allows for combining two different incidence timeseries.
The two timeseries can represent events that are differently delayed from the original infection events.
The two data sources must not have any overlap in the events recorded.
The function can account for the one of the two types of events to require
the future observation of the other type of event.
For instance, one type can be events of symptom onset, and the other be case confirmation.
Typically, the recording of a symptom onset event will require a future case confirmation.
If so, the \code{partial_observation_requires_full_observation} flag should be set to \code{TRUE}.
}
\examples{
## Basic usage of get_bootstrapped_estimates_from_combined_observations
# (Only 10 bootstrap replicates are generated to keep the code fast. In practice,
# use more.)

shape_incubation = 3.2
scale_incubation = 1.3
delay_incubation <- list(name="gamma", shape = shape_incubation, scale = scale_incubation)

shape_onset_to_report = 2.7
scale_onset_to_report = 1.6
delay_onset_to_report <- list(name="gamma",
                              shape = shape_onset_to_report,
                              scale = scale_onset_to_report)


Re_estimate_1 <- get_bootstrapped_estimates_from_combined_observations(
  partially_delayed_incidence = HK_incidence_data$onset_incidence,
  fully_delayed_incidence = HK_incidence_data$report_incidence,
  partial_observation_requires_full_observation = TRUE,
  delay_until_partial = delay_incubation,
  delay_until_final_report = delay_onset_to_report,
  N_bootstrap_replicates = 10
)


## Advanced usage of get_bootstrapped_estimates_from_combined_observations
# Incorporating prior knowledge over Re. Here, Re is assumed constant over a time
# frame of one week, with a prior mean of 1.25.
Re_estimate_2 <- get_bootstrapped_estimates_from_combined_observations(
  partially_delayed_incidence = HK_incidence_data$onset_incidence,
  fully_delayed_incidence = HK_incidence_data$report_incidence,
  partial_observation_requires_full_observation = TRUE,
  delay_until_partial = delay_incubation,
  delay_until_final_report = delay_onset_to_report,
  N_bootstrap_replicates = 10,
  estimation_method = 'EpiEstim piecewise constant',
  interval_length = 7,
  mean_Re_prior = 1.25,
  ref_date = HK_incidence_data$date[1]
)


# Incorporating prior knowledge over the disease. Here, we assume the mean of the
# serial interval to be 5 days, and the deviation is assumed to be 2.5 days. The
# delay between symptom onset and case confirmation is passed as empirical data.
Re_estimate_3 <- get_bootstrapped_estimates_from_combined_observations(
  partially_delayed_incidence = HK_incidence_data$onset_incidence,
  fully_delayed_incidence = HK_incidence_data$report_incidence,
  partial_observation_requires_full_observation = TRUE,
  delay_until_partial = delay_incubation,
  delay_until_final_report = delay_onset_to_report,
  N_bootstrap_replicates = 10,
  mean_serial_interval = 5,
  std_serial_interval = 2.5
)



}
